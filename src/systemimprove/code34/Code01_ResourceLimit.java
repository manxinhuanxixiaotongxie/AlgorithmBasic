package systemimprove.code34;

public class Code01_ResourceLimit {

    /**
     *
     *资源限制类题目解决套路
     *1.布隆过滤器用于集合的建立与查询，并可以节省大量的空间
     * code25.Code01_Hash 有做具体的讲解
     *
     *
     * 2.一致性hash解决服务器的负载管理问题
     * code25.Code01_Hash 有做具体的讲解 采用虚拟节点的方式
     *
     * 3.利用并查集做岛问题的并行计算
     *   并查集做岛问题 解决连通性
     *   经典的并查集使用的HashMap来做
     *   也可以使用数组来做 减少寻址时间
     *
     *
     * 4.hash函数可以把数据按照种类均匀分流
     *
     * 统计40亿数的大文件 里面出现次数最多的数是多少
     *
     *
     * 5.位图可以解决某一范围上数字出现情况，并可以节省大量的空间
     *
     *       32位无符号整数的范围是0~4,294,967,295，
     *       现在有一个正好包含40亿个无符号整数的文件，
     *       所以在整个范围中必然存在没出现过的数。
     *       可以使用最多1GB的内存，怎么找到所有未出现过的数？
     *       使用位图
     *       【进阶】
     *       内存限制为 3KB，但是只用找到一个没出现过的数即可
     *
     *
     * 6.利用分段统计思想进一步节省大量空间
     *
     *
     * 7.利用堆 外排序来做多个处理单元的结果合并
     *
     *
     *
     *
     */

    public void problem4() {

        /**
         * 32位无符号整数的范围是0~4,294,967,295，
         * 现在有一个正好包含40亿个无符号整数的文件，
         * 可以使用最多1GB的内存，怎么找到出现次数最多的数？
         *
         * 直接使用数组进行排序 那么数组占用的空间是 4,294,967,295*4/1024/1024/1024 = 16GB 不可行
         *
         * 使用hash函数 按照数的种类进行分类
         *
         *
         *
         * 这个问题的对应的问题4 把数据按照种类均匀分流
         *
         * hash函数有一个基本的特性：相同的输入一定会产生相同的输出
         * 基于此 那么我们可以得出一个结论 相同种类的数一定会分流到相同桶中
         *
         * 按照题目的描述 有一个正好包含40亿个数的无符号整数的文件
         * 那么最多有40亿种数 注意这里说的是种数 不是40亿个数
         * 我们切分的这个文件 按照数的种类来分流
         * 为什么要这么处理：
         * 是按照种树进行切分  不是按照种数
         * 我们想象两个极端的情况：
         * 1.只有一种数 如果只有一种数的话  那么hash之后一定会在一个桶中 占用的空间是多少 Map<Integer,Integer>占用的空间是 8个字节
         * 注意：可能远远不止这个空间的占用 因为hash表内部维护的索引信息 数据结构这些可能会占用更多的空间  但是并不会超过1GB
         * 2.有40亿种数
         *  这种种类最多的极端情况 会占用占用空间 现在我们有1GB的空间  假设 一个数占用的空间内存是8字节
         *  那么 估算一下 1GB = 1024MB = 1024*1024KB = 1024*1024*1024B = 1024*1024*1024/8=134,217,728个数 大概能存下1.3亿个数
         *
         *  由于hash表内部维护的节点信息等会占用更多的空间 我们保守估计  假设只能存一千万条数据
         *
         *  那么我们可以把这40亿个数分流到400个桶中 每个桶里面存储的是相同种类的数（提现在hash表可以将数据的均匀分流）
         *
         *  将这40亿个数取得一个hash值之后 再对400取模  就可以得到一个桶的编号 就能将数据分流到对应的桶中
         *
         * 推广：
         * 假设面试官问你  给你一个大文件 但是卡内存限制  统计大文件的某些东西 但是直接使用内存做hash或者其他结构内存汇报 常见的处理思路：
         *
         * 把大文件通过hash函数算出一个hash值再模一个东西 分到一个机器上
         * 0号机器上下一条数据再模出一个东西 发送到下一个机器上 如果这个机器的上还是大
         * 在机器上再选用一个hash函数再模一个东西 一直分到一个机器上的数据量小于内存限制
         *
         * 大文件hash之后分到小机器 如果还想用第二个hash函数算出模值再分小文件就可以把大文件的问题化小
         * 最后最多跑一个map reduce或者内存够用的情况下分别得到一个答案 再做整合
         *
         *
         *
         */

    }

    public void problem5() {
        /**
         * 32位无符号整数的范围是0~4,294,967,295，
         * 现在有一个正好包含40亿个无符号整数的文件，
         * 所以在这个文件中必然有没有出现过的数
         * 找出所有没有出现过的数
         * 最多可以使用1GB的内存
         *
         * 这里之前有点算错了  还要乘数组本身一个int占用4B的数据量
         * 假设使用位图的话 40亿个数的占用空间是 4000000000/32/1024/1024*4 = 476MB
         * 空间足够
         * 怎么在位图中找到没有出现过的数呢？
         *
         * 假如一个位图怎么加
         * int[x>> 5] |= 1 << (x % 31)
         * 找到一个数是不是在位图中
         * int[x >> 5] & 1 << (x % 31)
         *
         * 总共40亿个数
         * 将40亿个数放在位图中
         * for(inr i = 0; i < 40亿;i++) {
         *     int[x>> 5] |= 1 << (x & 31)
         * }
         * // 找到哪些数不在
         * 错误示范：
         * for(int i = 0; i < 2^32/32;i++) {
         *     for(int j = 0; j < 32;j++) {
         *         if((int[i] & 1 << j) == 0) {
         *             // 不在
         *         }else {
         *             // 在
         *         }
         *     }
         * }
         *
         * for {
         *     int status = int[x >> 5] & 1 << (x & 31)
         *     if(status == 0) {
         *      该数不存在
         *     }els{
         *         该数存在
         *     }
         * }
         *
         *
         * 进阶：
         * 最多使用3KB的空间 但是只需要找到一个没有出现过的数即可
         * 3KB = 3*1024 = 3072个B比特
         * 一个int 4个B 3072/4 = 768个int
         * 为了保证不超
         * 我们以最靠近768但是比768小的数作为位图的大小
         * 那么int数组的长度是512 不会查过限制大小
         *
         *
         * 使用分段统计思想进一步节省大量空间
         *
         * 将4,294,967,295个数分成512份 每份大概装下的数是 4,294,967,296/512 = 8388608
         * 第一个桶放下的位置是 0~8388607，这个桶存放数的个数
         * 第二个桶放下的位置是 8388608~16777215
         * 。。。
         * 第512个桶放下的位置是 2^32-8388608~2^32-1
         * 因为有42亿多的位置 只有40亿个数  根据鸽笼原理  一定会存在某个桶的数量不足8388607个数
         ＊因为桶存放的是范围，举个例子，在遍历过程中＇发现一个数是10亿'那么就在10亿／18388608桶中，就将该桶的数量+1
         * 那么我们就可以找到这个桶 继续分下去 就能找到一个没有出现过的数
         *
         * 进阶：只允许使用几个有限的变量怎么做
         * 二分查找   L=0 mid = 2^32/2 R = 2^32
         * 总是有一边是不满2^31的个数
         * 继续二分
         */
    }

    public void problem6() {
        /**
         * 有一个包含100亿个URL的大文件，假设每个URL占用64B，
         * 请找出其中所有重复的URL
         * 【补充】
         * 某搜索公司一天的用户搜索词汇是海量的(百亿数据量)，
         *
         * 请设计一种求出每天热门Top100词汇的可行办法
         *
         *
         * 找到重复的URL：
         * 1.使用布隆过滤器  但是有失误率 要求没有失误率的话 不能使用布隆过滤器
         * 2.hash的方式把大文件拆分成小文件 小文件还不够 再进行拆分 检查是不是有重复的URL就可以了
         * 原理：相同的url一定可以进入到同一个桶中 即进入到相同的文件
         *
         *
         * 补充：
         * 找到top100可以使用堆上堆 
         ＊思路：假设对空间是有要求的，那么根据哈希函数特性，相洞类型的词汇必燃进相同的桶＇那么就可以在每个桶中找到前几位的数字，
         ＊将所有桶放在起每个桶找到最人值放入中＇实现个堆中堆
         */
    }

    public void problem7() {
        /**
         * 32位无符号整数的范围是0~4294967295，
         * 现在有40亿个无符号整数，
         * 可以使用最多1GB的内存，
         * 找出所有出现了两次的数。
         *
         *
         * 使用位图 每两位表示一个数 该两位的值为11的时候 表示这个数出现了三次及以上
         *
         * 但是注意 有可能使用位图的时候 会超过1GB的内存限制
         * 那么就需要使用分段统计的思想
         * 先统计2^31个数 然后再统计2^31~2^32的数
         *
         * 位图+分段的统计 这些套路组合使用
         *
         *
         */
    }

    public void problem8() {
        /**
         * 32位无符号整数的范围是0~4294967295，现在有40亿个无符号整数
         * 可以使用最多3K的内存，怎么找到这40亿个整数的中位数？
         * 规定找的是上中位数
         *
         * 只有3KB的内存限制 申请一个长度为512的数组 将文件拆分成512份
         *
         * 在每一份上上求数量 然后我们在所有的文件中找到中位数
         *
         * 统计每一分出现了多少个数 找到第二十亿个数为止
         *
         */
    }

    public void problem9() {
        /**
         * 32位无符号整数的范围是0~4294967295，
         * 有一个10G大小的文件，每一行都装着这种类型的数字，
         * 整个文件是无序的，给你5G的内存空间，
         * 请你输出一个10G大小的文件，就是原文件所有数字排序的结果
         *
         *
         * 使用堆：
         *
         * 为了说明整个过程 我们先假设堆的大小是3
         *
         * 遍历文件（注意这里要一行一行的遍历 不能 一口气将文件加载到内存）
         *
         *
         * 堆中放的是对象  某个数以及某个数出现的次数
         *
         *
         * 第一个数出现了3   将（3,1）放进去 第二个数出现了2  将（2,2）放进去  第三个数出现了1  将（1,3）放进去
         * 然后再出现3 将（3,1）更新成（3,2）  然后再出现2 将（2,2）更新成（2,3）
         *
         * 保证堆中的数据是有序的
         * 后面又来个7  比最大值3要大   那么将最大值3踢出去 将（7,1）放进去
         *
         * 然后将这个数写进去   经过这么一个过程  之后 能将文件排好序
         *
         *
         * 现在堆的内存大小限制是5G 经过不了多少次原始文件的遍历就可以将原始文件找出来
         *
         * 使用堆结构维持了一个门槛堆
         *
         *
         *
         */
    }

    public void  problem10() {
        /**
         *堆上堆
         *
         * 请你求出一个大文件里出现次数最多的前100名。
         *
         * 第一步：将大文件拆分成小文件
         *
         * 第二步：每个小文件求前100名
         *
         * 第一个文件： a 19次 b 16次 c 10次
         * 第二个文件： x 23次 y 21次 p 6次
         * 第三个文件： z 9次 k 9次 f 9次
         *
         *
         *
         */
    }

}
