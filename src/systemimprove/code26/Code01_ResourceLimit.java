package systemimprove.code26;

public class Code01_ResourceLimit {

    /**
     *
     *资源限制类题目解决套路
     *1.布隆过滤器用于集合的建立与查询，并可以节省大量的空间
     * code25.Code01_Hash 有做具体的讲解
     *
     *
     * 2.一致性hash解决服务器的负载管理问题
     * code25.Code01_Hash 有做具体的讲解 采用虚拟节点的方式
     *
     * 3.利用并查集做岛问题的并行计算
     *   并查集做岛问题 解决连通性
     *   经典的并查集使用的HashMap来做
     *   也可以使用数组来做 减少使用
     *
     *
     * 4.hash函数可以把数据按照种类均匀分流
     *
     * 统计40亿数的大文件 里面出现次数最多的数是多少
     *
     *
     * 5.位图可以解决某一范围上数字出现情况，并可以节省大量的空间
     * 6.利用分段统计思想进一步节省大量空间
     * 7.利用堆 外排序来做多个处理单元的结果合并
     *
     *
     *
     *
     */

    public void problem4() {

        /**
         * 32位无符号整数的范围是0~4,294,967,295，
         * 现在有一个正好包含40亿个无符号整数的文件，
         * 可以使用最多1GB的内存，怎么找到出现次数最多的数？
         *
         * 直接使用数组进行排序 那么数组占用的空间是 4,294,967,295*4/1024/1024/1024 = 16GB 不可行
         *
         * 如果使用hash函数 单纯按照
         *
         *
         *
         * 这个问题的对应的问题4 把数据按照种类均匀分流
         *
         * hash函数有一个基本的特性：相同的输入一定会产生相同的输出
         * 基于此 那么我们可以得出一个结论 相同种类的数一定会分流到相同桶中
         *
         * 按照题目的描述 有一个正好包含40亿个数的无符号整数的文件
         * 那么最多有40亿种树 注意这里说的是种树 不是40亿个数
         * 我们切分的这个文件 按照数的种类来分流
         * 为什么要这么处理：
         * 是按照种树进行切分  不是按照种数
         * 我们想象两个极端的情况：
         * 1.只有一种数 如果只有一种数的话  那么hash之后一定会在一个桶中 占用的空间是多少 Map<Integer,Integer>占用的空间是 8个字节
         * 注意：可能远远不止这个数 因为hash表内部维护的索引信息 数据结构这些可能会占用更多的空间  但是并不会超过1GB
         * 2.有40亿种数
         *  这种种类最多的极端情况 会占用占用空间 现在我们有1GB的空间  假设 一个数占用的空间内存是8字节
         *  那么 估算一下 1GB = 1024MB = 1024*1024KB = 1024*1024*1024B = 1024*1024*1024/8=134,217,728个数 大概能存下1.3亿个数
         *  由于hash表内部维护的节点信息等会占用更多的空间 我们保守估计  假设只能存一千万条数据
         *
         *  那么我们可以把这40亿个数分流到400个桶中 每个桶里面存储的是相同种类的数（提现在hash表可以将数据的均匀分流）
         *
         *  将这40亿个数取得一个hash值之后 再对400取模  就可以得到一个桶的编号 就能将数据分流到对应的桶中
         *
         * 推广：
         * 假设面试官问你  给你一个大文件 但是卡内存限制  统计大文件的某些东西 但是直接使用内存做hash或者其他结构内存汇报 常见的处理思路：
         *
         * 把大文件通过hash函数算出一个hash值再模一个东西 分到一个机器上
         * 0号机器上下一条数据再模出一个东西 发送到下一个机器上 如果这个机器的上还是大
         * 在机器上再选用一个hash函数再模一个东西 一直分到一个机器上的数据量小于内存限制
         *
         * 大文件hash之后分到小机器 如果还想用第二个hash函数算出模值再分小文件就可以把大文件的问题化小
         * 最后最多跑一个map reduce或者内存够用的情况下分别得到一个答案 再做整合
         *
         *
         *
         */

    }

    public void problem5() {
        /**
         * 32位无符号整数的范围是0~4,294,967,295，
         * 现在有一个正好包含40亿个无符号整数的文件，
         * 所以在这个文件中必然有没有出现过的数
         * 找出所有没有出现过的数
         * 最多可以使用1GB的内存
         *
         * 假设使用位图的话 40亿个数的占用空间是 2^32/8/1024/1024/1024 = 512MB
         * 空间足够
         * 怎么在位图中找到没有出现过的数呢？
         *
         * 假如一个位图怎么加
         * int[x>> 5] |= 1 << (x & 31)
         * 找到一个数是不是在位图中
         * int[x>> 5] & 1 << (x & 31)
         *
         * 总共40亿个数
         * 将40亿个数放在位图中
         * for(inr i = 0; i < 40亿;i++) {
         *     int[x>> 5] |= 1 << (x & 31)
         * }
         * // 找到哪些数不在
         * for(int i = 0; i < 2^32/32;i++) {
         *     for(int j = 0; j < 32;j++) {
         *         if((int[i] & 1 << j) == 0) {
         *             // 不在
         *         }else {
         *             // 在
         *         }
         *     }
         * }
         * 进阶：
         * 最多使用3KB的空间 但是只需要找到一个没有出现过的数即可
         * 3KB = 3*1024 = 3072个B
         * 一个int 4个B 3072/4 = 768个int
         * 为了保证不超
         * 我们以最靠近768但是比768小的数作为位图的大小
         * 那么int数组的长度是512 不会查过限制大小
         *
         * 将40亿个数
         */
    }

}
